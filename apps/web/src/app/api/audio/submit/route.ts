import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { z } from 'zod';
import { AudioJobSchema } from '@mindscript/schemas';

// Input schema from the builder form
const submitSchema = z.object({
  script: z.string().min(10).max(5000),
  voice: z.object({
    provider: z.enum(['openai', 'elevenlabs', 'uploaded']),
    voice_id: z.string().min(1),
    settings: z.object({
      speed: z.number().min(0.25).max(4.0).optional(),
      pitch: z.number().min(-2).max(2).optional(),
    }).optional(),
  }),
  music: z.object({
    id: z.string().optional(),
    volume_db: z.number().min(-20).max(0),
  }).optional(),
  solfeggio: z.object({
    enabled: z.boolean(),
    frequency: z.number().optional(),
    volume_db: z.number().min(-30).max(0),
  }).optional(),
  binaural: z.object({
    enabled: z.boolean(),
    band: z.enum(['delta', 'theta', 'alpha', 'beta', 'gamma']).optional(),
    volume_db: z.number().min(-30).max(0),
  }).optional(),
  title: z.string().min(1).max(255).optional(),
  duration: z.number().min(5).max(15).default(10),
});

type SubmitData = z.infer<typeof submitSchema>;

// Helper to map binaural band to beat frequencies
const binauralBandToFrequency = (band: string) => {
  const frequencies = {
    delta: { beatHz: 2, carrierHz: 200 },
    theta: { beatHz: 6, carrierHz: 210 },
    alpha: { beatHz: 10, carrierHz: 220 },
    beta: { beatHz: 20, carrierHz: 230 },
    gamma: { beatHz: 40, carrierHz: 240 },
  };
  return frequencies[band as keyof typeof frequencies] || frequencies.alpha;
};

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();

    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Parse and validate request body
    const body = await request.json();
    const data = submitSchema.parse(body);

    // Create track record first
    const trackData = {
      user_id: user.id,
      title: data.title || `Track ${new Date().toLocaleDateString()}`,
      description: data.script.substring(0, 200),
      script: data.script,
      voice_config: {
        provider: data.voice.provider,
        voice_id: data.voice.voice_id,
        settings: data.voice.settings || {},
      },
      music_config: data.music?.id ? {
        track_id: data.music.id,
        volume_db: data.music.volume_db,
      } : null,
      frequency_config: {
        solfeggio: data.solfeggio?.enabled ? {
          enabled: true,
          frequency: data.solfeggio.frequency || 528,
          volume_db: data.solfeggio.volume_db,
        } : null,
        binaural: data.binaural?.enabled ? {
          enabled: true,
          band: data.binaural.band || 'alpha',
          volume_db: data.binaural.volume_db,
        } : null,
      },
      output_config: {
        format: 'mp3',
        quality: 'standard',
        is_public: false,
      },
      status: 'draft',
      is_public: false,
      tags: [],
    };

    const { data: track, error: trackError } = await supabase
      .from('tracks')
      .insert(trackData)
      .select()
      .single();

    if (trackError) {
      console.error('Error creating track:', trackError);
      return NextResponse.json({ error: 'Failed to create track' }, { status: 500 });
    }

    // Map builder data to AudioJob schema for the queue
    const binauralConfig = data.binaural?.enabled && data.binaural?.band
      ? binauralBandToFrequency(data.binaural.band)
      : null;

    const audioJob = {
      track_id: track.id,
      user_id: user.id,
      status: 'pending',
      progress: 0,
      stage: 'queued',
      job_data: {
        voiceUrl: null, // Will be generated by TTS in Edge Function
        musicUrl: data.music?.id || null,
        durationMin: data.duration || 10,
        pauseSec: 3,
        loopMode: 'repeat',
        gains: {
          voiceDb: -1,
          musicDb: data.music?.volume_db || -10,
          solfeggioDb: data.solfeggio?.volume_db || -16,
          binauralDb: data.binaural?.volume_db || -18,
        },
        fade: {
          inMs: 1000,
          outMs: 1500,
        },
        channels: 2,
        outputFormat: 'mp3',
        solfeggio: data.solfeggio?.enabled ? {
          enabled: true,
          hz: data.solfeggio.frequency || 528,
          wave: 'sine',
        } : undefined,
        binaural: data.binaural?.enabled && binauralConfig ? {
          enabled: true,
          band: data.binaural.band || 'alpha',
          beatHz: binauralConfig.beatHz,
          carrierHz: binauralConfig.carrierHz,
        } : undefined,
        safety: {
          limiter: true,
          targetLufs: -16,
        },
        // Add voice and script info for TTS processing
        voice: {
          provider: data.voice.provider,
          voice_id: data.voice.voice_id,
          settings: data.voice.settings || {},
        },
        script: data.script,
        trackId: track.id,
      },
    };

    // Insert job into queue
    const { data: job, error: jobError } = await supabase
      .from('audio_job_queue')
      .insert(audioJob)
      .select()
      .single();

    if (jobError) {
      console.error('Error creating audio job:', jobError);

      // Clean up track if job creation failed
      await supabase
        .from('tracks')
        .delete()
        .eq('id', track.id);

      return NextResponse.json({ error: 'Failed to create audio job' }, { status: 500 });
    }

    // Update track with render job ID
    await supabase
      .from('tracks')
      .update({ render_job_id: job.id })
      .eq('id', track.id);

    // Trigger Edge Function to process the job
    try {
      const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
      const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

      if (supabaseUrl && supabaseAnonKey) {
        const response = await fetch(
          `${supabaseUrl}/functions/v1/audio-processor`,
          {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${supabaseAnonKey}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ action: 'process' }),
          }
        );

        if (!response.ok) {
          console.warn('Failed to trigger audio processor:', await response.text());
        }
      }
    } catch (triggerError) {
      console.warn('Could not trigger audio processor:', triggerError);
      // Don't fail the request if trigger fails - cron job will pick it up
    }

    return NextResponse.json({
      success: true,
      projectId: track.id,
      jobId: job.id,
      message: 'Audio rendering job created successfully',
      track: {
        id: track.id,
        title: track.title,
        status: track.status,
      },
      job: {
        id: job.id,
        status: job.status,
        progress: job.progress,
      },
    });
  } catch (error) {
    console.error('Error in POST /api/audio/submit:', error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid request data', details: error.errors },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}